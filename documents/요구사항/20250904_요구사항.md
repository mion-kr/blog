# 요구사항

## 시스템 요구 사항

### 프로젝트

- pnpm 패키지 관리
- Mono Repo 형식
- Next.js, Nest.js 코드가 있어야 함
  - apps/blog-web - next.js
  - apps/blog-api - nest.js
- turbo repo 적용 피룡료

#### Next.js

- Next.js 15
- App Router
- Tailwind CSS
- shadcn/ui
- SNS 인증
  - google만 지원

#### Nest.js

- Nest.js 최신
- Drizzle ORM
- Swagger

### 인프라

- Database: Neon Database 사용
- Next.js는 Vercel에 배포
- Nest.js는 Railway에 배포

### 로컬 환경 테스트

- 각 프로젝트를 Docker Container에서 실행하여 테스트 함

## 구현 진행 상황

### 완료된 작업

- [x] **Entity 작업 완료** - Drizzle ORM 스키마 정의 완료
- [x] **DTO 작업 완료** - 요청/응답 DTO 클래스 정의 완료
- [x] **Controller 작업 완료** - API 엔드포인트 구현 완료 (보일러플레이트 85% 감소)
- [x] **Service 작업 완료** - 비즈니스 로직 구현 완료 (목록 조회 메서드 복구 포함)

### 백엔드 구현 완료

- ✅ **전체 API 구현 완료**: Entity → DTO → Controller → Service 레이어
- ✅ **고급 기능 구현**: 페이징, 필터링, 검색, 정렬, 관계 데이터 처리
- ✅ **보안 시스템**: JWT 인증, ADMIN 권한, CSRF 보호
- ✅ **코드 최적화**: 보일러플레이트 85% 감소, 재사용 가능한 데코레이터 시스템

### ✅ **Phase 2: 프론트엔드 구현 완료** (2025-09-19)

#### **홈페이지 구현 완료** ✅ (2025-09-16)
- ✅ **포스트 목록 표시**: API 연동으로 실시간 포스트 카드 표시
- ✅ **반응형 그리드**: 모바일(1열) → 태블릿(2열) → 데스크톱(3열) 레이아웃
- ✅ **API 클라이언트**: Next.js와 Nest.js 완전 연동
- ✅ **타입 안전성**: shared 패키지 타입 활용한 완전한 타입 체크

#### **포스트 상세 페이지 완료** ✅ (2025-09-19)
- ✅ **MDX 렌더링**: `mdx-renderer.tsx` 컴포넌트로 마크다운 완전 렌더링
- ✅ **동적 라우팅**: `/posts/[slug]` 경로로 slug 기반 포스트 조회
- ✅ **공유 기능**: `share-button.tsx`로 소셜 미디어 공유 버튼
- ✅ **로딩/에러 처리**: `loading.tsx`, `not-found.tsx`로 UX 최적화
- ✅ **조회수 연동**: API 호출로 포스트 조회 시 조회수 자동 증가
- ✅ **헤더/푸터**: `site-header.tsx`, `site-footer.tsx`로 완전한 레이아웃

### 남은 작업

- [ ] **데이터베이스 마이그레이션** - 스키마 생성 및 테이블 마이그레이션 실행
- [ ] **관리자 페이지** - 포스트 CRUD 관리 인터페이스
- [ ] **검색/필터링** - 카테고리, 태그별 포스트 필터링
- [ ] **SEO 최적화** - 메타데이터, 사이트맵 구현

### 현재 상태

- ✅ **애플리케이션 정상 실행**: `http://localhost:3001`
- ✅ **Swagger 문서 활성화**: `http://localhost:3001/api-docs`
- ✅ **모든 API 엔드포인트 등록**: 15개 엔드포인트 매핑 완료
- ⚠️ **데이터베이스 테이블 없음**: categories, tags 테이블 생성 필요

### 컨트롤러 구현 결과

- ✅ **Posts Controller** - 5개 엔드포인트 (목록/상세/생성/수정/삭제)
- ✅ **Categories Controller** - 5개 엔드포인트 (목록/상세/생성/수정/삭제)
- ✅ **Tags Controller** - 5개 엔드포인트 (목록/상세/생성/수정/삭제)
- ✅ **공통 응답 데코레이터** - 재사용 가능한 API 응답 시스템 구축
- ✅ **보안 가드 적용** - JWT 인증, ADMIN 권한, CSRF 보호

## 기능 요구사항

### 개요

Mion의 기술 블로그 임. Github 블로그로 진행하려다가 AI의 도움을 받아 Next.js + Nest.js의 풀스택으로 구현 해보려고 함

### 주요 기능

- Post 등록/수정/조회/삭제 기능
- SNS 로그인 기능(google)

#### Post 기능

Post 작성은 Mion(나)만 작성가능.
Post의 내용은 Markdown을 지원해야 함. MDX

#### Post 스토리

Mion이 웹페이지 접속 -> Post가 목록 조회 됨 -> SNS 로그인하면 블로그 글쓰기 버튼이 보임 -> Markdown으로 내용을 적고 맨 위에 Header 1 부분이 블로그의 Title의 됨

## 데이터베이스 스키마

### 테이블 구조

#### Users 테이블 (Google OAuth 인증)

```typescript
interface User {
  id: string; // UUID, Primary Key
  email: string; // Google에서 받은 이메일 (Unique)
  name: string; // Google에서 받은 이름
  image?: string; // Google 프로필 이미지 URL
  googleId: string; // Google OAuth ID (Unique)
  role: "ADMIN" | "USER"; // Mion = ADMIN, 나머지 = USER
  createdAt: Date;
  updatedAt: Date;
}
```

#### Categories 테이블 (블로그 카테고리)

```typescript
interface Category {
  id: string; // UUID, Primary Key
  name: string; // 카테고리 이름 (예: "개발", "일상", "리뷰")
  slug: string; // URL 친화적 문자열 (예: "development", "daily", "review")
  description?: string; // 카테고리 설명
  color?: string; // 테마 색상 (hex 코드)
  createdAt: Date;
  updatedAt: Date;
}
```

#### Tags 테이블 (포스트 태그)

```typescript
interface Tag {
  id: string; // UUID, Primary Key
  name: string; // 태그 이름 (예: "Next.js", "TypeScript", "블로그")
  slug: string; // URL 친화적 문자열 (예: "nextjs", "typescript", "blog")
  createdAt: Date;
}
```

#### Posts 테이블 (블로그 포스트)

```typescript
interface Post {
  id: string; // UUID, Primary Key
  title: string; // 제목 (MDX H1에서 추출)
  slug: string; // URL 친화적 제목 (예: "my-first-post")
  content: string; // MDX 원본 내용
  excerpt?: string; // 요약 (자동 생성 또는 수동 입력)
  coverImage?: string; // 썸네일 이미지 URL
  published: boolean; // 발행 상태 (draft/published)
  viewCount: number; // 조회수 (기본값: 0)
  categoryId: string; // 카테고리 ID (Foreign Key)
  authorId: string; // 작성자 ID (Foreign Key - Mion만 가능)
  createdAt: Date;
  updatedAt: Date;
  publishedAt?: Date; // 발행일시
}
```

#### PostTags 테이블 (포스트-태그 Many-to-Many 관계)

```typescript
interface PostTag {
  postId: string; // Post ID (Foreign Key)
  tagId: string; // Tag ID (Foreign Key)
  createdAt: Date;
}
```

### Slug 개념 및 생성 규칙

#### Slug란?

- URL에서 사용되는 사용자 친화적이고 SEO에 최적화된 문자열
- 한글 제목을 영문으로 변환하여 URL에 사용

#### Slug 사용 예시

```bash
# 일반적인 ID 기반 URL (권장하지 않음)
https://blog.mion.dev/post/123e4567-e89b-12d3-a456-426614174000

# Slug 기반 URL (권장)
https://blog.mion.dev/post/nextjs-15-app-router-guide
https://blog.mion.dev/category/development
https://blog.mion.dev/tag/typescript
```

#### Slug 생성 규칙

1. **소문자 변환**: 모든 문자를 소문자로 변환
2. **특수문자 제거**: 알파벳, 숫자, 하이픈, 공백만 허용
3. **공백 처리**: 공백을 하이픈(-)으로 변환
4. **연속 하이픈 제거**: 여러 개의 하이픈을 하나로 변환
5. **길이 제한**: 최대 100자로 제한
6. **중복 방지**: 같은 테이블에서 중복되는 slug가 있으면 숫자 suffix 추가

#### Slug 변환 예시

```
"Next.js 15 App Router 완벽 가이드" → "nextjs-15-app-router-complete-guide"
"TypeScript와 함께하는 백엔드 개발" → "backend-development-with-typescript"
"React Server Components 이해하기!" → "understanding-react-server-components"
```

## URL 구조 설계

### 기본 페이지 URL

```bash
/                              # 홈페이지 (최신 포스트 목록)
/posts                         # 전체 포스트 목록
/post/[slug]                   # 포스트 상세페이지
```

### 카테고리 및 태그 URL

```bash
/category/[categorySlug]       # 카테고리별 포스트 목록
/tag/[tagSlug]                 # 태그별 포스트 목록
```

### 관리자 페이지 URL (Mion만 접근 가능)

```bash
/admin/write                   # 포스트 작성
/admin/posts                   # 포스트 관리
/admin/categories              # 카테고리 관리
/admin/tags                    # 태그 관리
```

### API 엔드포인트 URL

```bash
/api/auth/google               # Google OAuth 인증
/api/posts                     # 포스트 CRUD
/api/posts/[slug]              # 포스트 상세 조회/수정/삭제
/api/categories                # 카테고리 CRUD
/api/tags                      # 태그 CRUD
```

## 상세 기능 요구사항

### 카테고리 기능

- **카테고리 관리**: ADMIN만 생성/수정/삭제 가능
- **카테고리별 필터링**: 카테고리별 포스트 목록 조회
- **카테고리 색상 테마**: 각 카테고리별 고유 색상 설정
- **카테고리별 RSS 피드**: 카테고리별 RSS 생성

### 태그 기능

- **태그 자동완성**: 포스트 작성 시 기존 태그 자동완성 제공
- **태그별 필터링**: 태그별 포스트 목록 조회
- **인기 태그 표시**: 사용 빈도가 높은 태그 우선 표시
- **태그 클라우드**: 태그 사용량에 따른 시각적 표현

### 조회수 기능

- **중복 방지**: 같은 사용자의 중복 조회수 카운팅 방지 (IP 기반 또는 세션 기반)
- **실시간 업데이트**: 포스트 조회 시 조회수 즉시 반영
- **인기 포스트**: 조회수 기반 인기 포스트 순위
- **조회수 통계**: 일별, 월별 조회수 통계

### SEO 최적화

- **메타 데이터**: 각 포스트별 title, description, keywords 설정
- **Open Graph**: SNS 공유 시 미리보기 이미지 및 정보
- **사이트맵**: 자동 생성되는 XML 사이트맵
- **구조화된 데이터**: Schema.org 마크업 적용

### MDX 에디터 기능

- **실시간 미리보기**: 작성 중인 MDX 내용 실시간 렌더링
- **코드 하이라이팅**: 다양한 언어의 코드 블록 문법 강조
- **이미지 업로드**: 드래그 앤 드롭으로 이미지 업로드 지원
- **자동 저장**: 작성 중인 내용 자동 임시 저장

## 인증 및 보안 시스템

### 인증 방식

- **Google OAuth 2.0**: 유일한 로그인 방식
- **JWT 토큰**: Stateless 인증으로 Vercel + Railway 환경에 최적화
- **NextAuth.js**: Next.js 15와 완벽 호환되는 인증 라이브러리 사용

### 사용자 권한 시스템

#### 권한 레벨

```typescript
enum UserRole {
  ADMIN = "ADMIN", // Mion님 - 모든 권한
  USER = "USER", // 일반 사용자 - 읽기 전용
}
```

#### 권한별 기능 매트릭스

```typescript
const PERMISSIONS = {
  ADMIN: {
    // 포스트 관련
    createPost: true,
    editPost: true,
    deletePost: true,
    publishPost: true,

    // 카테고리/태그 관리
    manageCategories: true,
    manageTags: true,

    // 사이트 관리
    viewAnalytics: true,
    manageUsers: true,
  },
  USER: {
    // 읽기 전용
    viewPosts: true,
    viewPublicProfile: true,

    // 향후 확장성을 위해 미리 정의
    createComment: false, // 나중에 댓글 기능 추가 시 활성화
    editOwnComment: false,
  },
};
```

### Mion 계정 구분 방법

- **환경변수 기반**: `ADMIN_EMAIL` 환경변수에 Mion님의 Google 이메일 설정
- **자동 역할 할당**: Google 로그인 시 이메일을 비교하여 ADMIN/USER 역할 자동 할당
- **실시간 권한 확인**: 로그인할 때마다 권한 재확인으로 보안 강화

```typescript
// 권한 확인 로직
export function getUserRole(email: string): UserRole {
  return email === process.env.ADMIN_EMAIL ? UserRole.ADMIN : UserRole.USER;
}
```

### JWT 토큰 구조

```typescript
interface JWTPayload {
  sub: string; // 사용자 ID (UUID)
  email: string; // Google 이메일
  name: string; // Google에서 받은 이름
  role: UserRole; // ADMIN 또는 USER
  iat: number; // 발급 시간
  exp: number; // 만료 시간 (7일)
}
```

### CSRF 보안 시스템

#### CSRF 공격이란?

- **Cross-Site Request Forgery**: 사용자가 의도하지 않은 요청이 악의적인 사이트를 통해 실행되는 공격
- **공격 원리**: 사용자가 블로그에 로그인된 상태에서 악성 사이트 방문 시, 몰래 포스트 생성/수정 등이 실행될 수 있음
- **위험성**: 사용자 모르게 블로그 내용이 변경되거나 삭제될 수 있음

#### CSRF Token 보호 방식

```typescript
// NextAuth.js CSRF 보호 설정
export default NextAuth({
  cookies: {
    csrfToken: {
      name: `__Secure-next-auth.csrf-token`,
      options: {
        httpOnly: true, // JavaScript로 접근 불가
        sameSite: "lax", // 크로스 사이트 요청 제한
        path: "/",
        secure: true, // HTTPS에서만 전송
      },
    },
    sessionToken: {
      name: `__Secure-next-auth.session-token`,
      options: {
        httpOnly: true,
        sameSite: "lax",
        secure: true,
      },
    },
  },
});
```

#### API 요청 시 CSRF Token 사용

```typescript
// 포스트 작성/수정 시 CSRF 토큰 포함
const csrfToken = await getCsrfToken();

fetch("/api/posts", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
    "X-CSRF-Token": csrfToken, // CSRF 토큰 헤더에 포함
  },
  body: JSON.stringify(postData),
});
```

### API 보안 설정

#### Nest.js 인증 가드

```typescript
// JWT 인증 가드
@Injectable()
export class JwtAuthGuard implements CanActivate {
  constructor(private jwtService: JwtService) {}

  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest();
    const token = this.extractTokenFromHeader(request);

    if (!token) {
      throw new UnauthorizedException();
    }

    const payload = this.jwtService.verify(token);
    request.user = payload;
    return true;
  }
}

// ADMIN 전용 가드
@Injectable()
export class AdminGuard extends JwtAuthGuard {
  canActivate(context: ExecutionContext): boolean {
    const isAuthenticated = super.canActivate(context);
    if (!isAuthenticated) return false;

    const request = context.switchToHttp().getRequest();
    if (request.user.role !== UserRole.ADMIN) {
      throw new ForbiddenException("Admin access required");
    }

    return true;
  }
}
```

#### CSRF 검증 가드

```typescript
@Injectable()
export class CSRFGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest();
    const allowedOrigins = [
      "https://blog.mion.dev",
      "http://localhost:3000", // 개발환경
    ];

    const origin = request.headers.origin;
    const referer = request.headers.referer;

    // Origin 또는 Referer가 허용된 도메인인지 확인
    if (
      !this.isValidOrigin(origin, allowedOrigins) &&
      !this.isValidReferer(referer, allowedOrigins)
    ) {
      throw new ForbiddenException("Invalid origin");
    }

    return true;
  }
}
```

#### API 엔드포인트 보안 적용

```typescript
@Controller("posts")
export class PostsController {
  @Get()
  findAll() {
    // 인증 없이 접근 가능 (공개 포스트 조회)
  }

  @Post()
  @UseGuards(AdminGuard, CSRFGuard) // ADMIN 권한 + CSRF 보호
  create(@Body() createPostDto: CreatePostDto) {
    // 포스트 생성 (Mion만 가능)
  }

  @Put(":slug")
  @UseGuards(AdminGuard, CSRFGuard) // ADMIN 권한 + CSRF 보호
  update(@Param("slug") slug: string, @Body() updatePostDto: UpdatePostDto) {
    // 포스트 수정 (Mion만 가능)
  }

  @Delete(":slug")
  @UseGuards(AdminGuard, CSRFGuard) // ADMIN 권한 + CSRF 보호
  remove(@Param("slug") slug: string) {
    // 포스트 삭제 (Mion만 가능)
  }
}
```

### 보안 강화 설정

#### CORS 설정

```typescript
// main.ts - Nest.js 서버 설정
app.enableCors({
  origin: [
    "https://blog.mion.dev", // 프로덕션 도메인
    "http://localhost:3000", // 개발 환경
  ],
  credentials: true, // 쿠키 포함 허용
  methods: ["GET", "POST", "PUT", "DELETE"],
  allowedHeaders: ["Content-Type", "Authorization", "X-CSRF-Token"],
});
```

#### 보안 헤더 설정

```typescript
// 기본 보안 헤더 적용
app.use(
  helmet({
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        scriptSrc: ["'self'", "'unsafe-inline'", "https://apis.google.com"],
        styleSrc: ["'self'", "'unsafe-inline'"],
        imgSrc: ["'self'", "data:", "https:"],
      },
    },
  })
);
```

### 환경변수 설정

```bash
# .env.local (Next.js)
NEXTAUTH_URL=https://blog.mion.dev
NEXTAUTH_SECRET=your-secret-key
GOOGLE_CLIENT_ID=your-google-client-id
GOOGLE_CLIENT_SECRET=your-google-client-secret
ADMIN_EMAIL=mion@example.com

# .env (Nest.js)
JWT_SECRET=your-jwt-secret
DATABASE_URL=your-neon-database-url
FRONTEND_URL=https://blog.mion.dev
```

## UI/UX 디자인 시스템

### 디자인 컨셉

- **스타일**: Aura 블로그에서 영감을 받은 모던 미니멀 디자인
- **레퍼런스**: Dribbble "Aura Website – Blog" by Maria Brilkova
- **컨셉**: 깔끔하고 읽기 쉬운 개발자 친화적 블로그
- **다크모드**: 지원하지 않음 (라이트 모드만 제공)

### 레이아웃 구조

- **카드 기반 그리드 시스템**: 포스트들을 카드 형태로 배치
- **더블 사이즈 카드**: 중요한 포스트는 2배 크기로 강조 표시
- **미니멀한 네비게이션**: 깔끔한 상단 네비게이션 바
- **여백 활용**: 충분한 여백으로 가독성 향상

### 반응형 디자인 시스템

#### 브레이크포인트 정의 (Tailwind CSS 기준)

```css
xs: '475px',    /* 작은 모바일 */
sm: '640px',    /* 큰 모바일 */
md: '768px',    /* 태블릿 */
lg: '1024px',   /* 작은 노트북 */
xl: '1280px',   /* 데스크톱 */
2xl: '1536px'   /* 큰 데스크톱 */
```

#### 디바이스별 레이아웃 전략

##### 모바일 (320px ~ 767px)

- **1컬럼 레이아웃**: 포스트 카드 세로 배치
- **햄버거 메뉴**: 네비게이션을 접을 수 있는 메뉴로 변환
- **터치 친화적 UI**: 44px 이상의 터치 타겟 크기 보장
- **모바일 최적화**: 이미지 압축 및 적절한 크기 조정
- **스와이프 제스처**: 카드 간 스와이프 네비게이션 지원

##### 태블릿 (768px ~ 1023px)

- **2컬럼 레이아웃**: 포스트 카드 2개씩 나란히 배치
- **접이식 사이드바**: 필요시 접고 펼칠 수 있는 네비게이션
- **큰 타이포그래피**: 태블릿에 최적화된 폰트 크기
- **터치/마우스 하이브리드**: 두 입력 방식 모두 지원

##### 데스크톱 (1024px+)

- **3컬럼 레이아웃**: 포스트 카드 3개씩 배치
- **풀 네비게이션**: 모든 메뉴 항목 표시
- **사이드바 활용**: 카테고리/태그 네비게이션 고정 표시
- **호버 효과**: 마우스 인터랙션 최적화

### 색상 관리 시스템

#### CSS Custom Properties 기반 색상 시스템

```css
/* globals.css - 기본 색상 변수 정의 */
:root {
  /* Primary Colors */
  --color-primary-50: #f8fafc;
  --color-primary-100: #f1f5f9;
  --color-primary-500: #64748b;
  --color-primary-900: #0f172a;

  /* Accent Colors */
  --color-accent-primary: #3b82f6;
  --color-accent-secondary: #8b5cf6;
  --color-accent-success: #10b981;
  --color-accent-warning: #f59e0b;
  --color-accent-error: #ef4444;

  /* Semantic Colors */
  --color-background: var(--color-primary-50);
  --color-surface: #ffffff;
  --color-text-primary: var(--color-primary-900);
  --color-text-secondary: var(--color-primary-500);
  --color-border: var(--color-primary-100);
}
```

#### 테마 변경 시스템

- **동적 색상 변경**: CSS 변수를 통한 실시간 테마 변경
- **다중 테마 지원**: 여러 가지 색상 테마 미리 정의
- **관리자 인터페이스**: Mion님이 쉽게 색상을 변경할 수 있는 UI 제공
- **일관성 보장**: 모든 컴포넌트에서 동일한 색상 시스템 사용

#### Tailwind CSS 색상 확장

```javascript
// tailwind.config.js
module.exports = {
  theme: {
    extend: {
      colors: {
        // Primary brand colors
        brand: {
          50: "var(--color-primary-50)",
          100: "var(--color-primary-100)",
          500: "var(--color-primary-500)",
          900: "var(--color-primary-900)",
        },
        // Accent colors
        accent: {
          primary: "var(--color-accent-primary)",
          secondary: "var(--color-accent-secondary)",
          success: "var(--color-accent-success)",
          warning: "var(--color-accent-warning)",
          error: "var(--color-accent-error)",
        },
        // Semantic colors
        background: "var(--color-background)",
        surface: "var(--color-surface)",
        "text-primary": "var(--color-text-primary)",
        "text-secondary": "var(--color-text-secondary)",
        border: "var(--color-border)",
      },
    },
  },
};
```

### 컴포넌트 디자인 가이드라인

#### 포스트 카드 컴포넌트

- **라운드 코너**: 부드러운 느낌의 둥근 모서리 (border-radius: 12px)
- **그림자 효과**: 카드 깊이감을 위한 subtle shadow
- **호버 효과**: 마우스 호버 시 약간의 elevation 효과
- **이미지 비율**: 16:9 또는 4:3 비율로 일관성 유지
- **텍스트 계층**: 제목, 요약, 메타정보의 명확한 위계 구조

#### 네비게이션 컴포넌트

- **고정 헤더**: 스크롤 시에도 상단에 고정
- **브랜드 로고**: 왼쪽 상단에 "Mion's Blog" 로고
- **메뉴 항목**: 홈, 카테고리, 태그, 검색 기능
- **로그인 버튼**: 우측 상단에 Google 로그인 버튼

#### 타이포그래피 가이드라인

```css
/* 타이포그래피 스케일 */
--font-size-xs: 0.75rem; /* 12px */
--font-size-sm: 0.875rem; /* 14px */
--font-size-base: 1rem; /* 16px */
--font-size-lg: 1.125rem; /* 18px */
--font-size-xl: 1.25rem; /* 20px */
--font-size-2xl: 1.5rem; /* 24px */
--font-size-3xl: 1.875rem; /* 30px */
--font-size-4xl: 2.25rem; /* 36px */

/* 폰트 무게 */
--font-weight-normal: 400;
--font-weight-medium: 500;
--font-weight-semibold: 600;
--font-weight-bold: 700;
```

### 접근성 (Accessibility) 요구사항

- **키보드 네비게이션**: 모든 인터랙티브 요소에 키보드 접근 가능
- **색상 대비**: WCAG 2.1 AA 레벨 준수 (4.5:1 이상)
- **포커스 표시**: 명확한 포커스 인디케이터 제공
- **스크린 리더**: 적절한 ARIA 레이블 및 시맨틱 HTML 사용
- **대체 텍스트**: 모든 이미지에 의미있는 alt 속성 제공

### 성능 최적화 요구사항

- **이미지 최적화**: WebP 포맷 우선, 적절한 크기 조정
- **레이지 로딩**: 화면 밖 이미지들의 지연 로딩
- **폰트 최적화**: 시스템 폰트 우선, 웹폰트 최소화
- **번들 최적화**: 코드 스플리팅 및 Tree shaking 적용
- **캐싱 전략**: 정적 자원의 적극적 캐싱
