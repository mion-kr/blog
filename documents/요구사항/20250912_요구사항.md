# ìš”êµ¬ì‚¬í•­

## Pino Logger í†µí•© ì‹œìŠ¤í…œ êµ¬ì¶•

### ğŸ“‹ ì„¤ê³„ ë°°ê²½

ê¸°ì¡´ ResponseInterceptorì™€ GlobalExceptionFilter ì‹œìŠ¤í…œì— **pino ë¡œê±°**ë¥¼ ì™„ì „ í†µí•©í•˜ì—¬ **êµ¬ì¡°í™”ëœ ê³ ì„±ëŠ¥ ë¡œê¹… ì‹œìŠ¤í…œ**ì„ êµ¬ì¶•í•©ë‹ˆë‹¤.

### ğŸ¯ í•µì‹¬ ìš”êµ¬ì‚¬í•­

1. **ì„±ëŠ¥ ìµœì í™”**: í”„ë¡œë•ì…˜ í™˜ê²½ì—ì„œ ìµœê³  ì„±ëŠ¥ì˜ ë¡œê¹…
2. **êµ¬ì¡°í™”ëœ ë¡œê¹…**: JSON í˜•íƒœì˜ êµ¬ì¡°í™”ëœ ë¡œê·¸ ë°ì´í„°
3. **ì™„ì „ í†µí•©**: ê¸°ì¡´ ResponseInterceptor/ErrorFilterì™€ seamless í†µí•©
4. **ê°œë°œì ê²½í—˜**: ê°œë°œ í™˜ê²½ì—ì„œ ê°€ë…ì„± ì¢‹ì€ pretty-print
5. **ì¤‘ì•™ ì§‘ì¤‘ ê´€ë¦¬**: ëª¨ë“  ë¡œê·¸ ì„¤ì •ì´ í•œ ê³³ì—ì„œ ê´€ë¦¬

## ğŸš€ 1ë‹¨ê³„: íŒ¨í‚¤ì§€ ì„¤ì¹˜ ë° ê¸°ë³¸ ì„¤ì •

### ğŸ“¦ í•„ìˆ˜ íŒ¨í‚¤ì§€ ì„¤ì¹˜

```bash
# Pino í•µì‹¬ íŒ¨í‚¤ì§€ë“¤
pnpm --filter=blog-api add pino nestjs-pino pino-pretty

# ê°œë°œ í™˜ê²½ìš© (ì„ íƒì‚¬í•­)  
pnpm --filter=blog-api add -D pino-dev
```

### ğŸ¯ íŒ¨í‚¤ì§€ë³„ ì—­í• 

| íŒ¨í‚¤ì§€ | ì—­í•  | ì‚¬ìš© í™˜ê²½ |
|--------|------|----------|
| `pino` | í•µì‹¬ ë¡œê±° | ëª¨ë“  í™˜ê²½ |
| `nestjs-pino` | NestJS í†µí•© | ëª¨ë“  í™˜ê²½ |
| `pino-pretty` | ê°€ë…ì„± ê°œì„  | ê°œë°œ í™˜ê²½ |
| `pino-dev` | ê°œë°œ ë„êµ¬ | ê°œë°œ í™˜ê²½ë§Œ |

## ğŸ”§ 2ë‹¨ê³„: Pino ì„¤ì • ì‹œìŠ¤í…œ

### ğŸ“„ í™˜ê²½ë³€ìˆ˜ ì„¤ì •

```bash
# apps/blog-api/.env ì¶”ê°€
LOG_LEVEL=debug           # ê°œë°œ: debug, ìš´ì˜: info
LOG_PRETTY_PRINT=true     # ê°œë°œ: true, ìš´ì˜: false
LOG_TIMESTAMP=true        # íƒ€ì„ìŠ¤íƒ¬í”„ í¬í•¨ ì—¬ë¶€
LOG_FILE_PATH=./logs      # ë¡œê·¸ íŒŒì¼ ì €ì¥ ê²½ë¡œ (ì„ íƒì‚¬í•­)
```

### ğŸ›ï¸ Pino êµ¬ì„± ëª¨ë“ˆ

```typescript
// apps/blog-api/src/config/logger.config.ts

import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { Params } from 'nestjs-pino';
import * as path from 'path';

@Injectable()
export class LoggerConfigService {
  constructor(private configService: ConfigService) {}

  createLoggerConfig(): Params {
    const isProduction = process.env.NODE_ENV === 'production';
    const isDevelopment = process.env.NODE_ENV === 'development';
    
    return {
      pinoHttp: {
        // ğŸ¯ ë¡œê·¸ ë ˆë²¨ ì„¤ì •
        level: this.configService.get('LOG_LEVEL', isProduction ? 'info' : 'debug'),
        
        // ğŸ¨ ê°œë°œ í™˜ê²½ Pretty Print ì„¤ì •
        ...(isDevelopment && {
          transport: {
            target: 'pino-pretty',
            options: {
              colorize: true,
              levelFirst: true,
              translateTime: 'yyyy-mm-dd HH:MM:ss',
              messageFormat: '{req.method} {req.url} - {msg}',
              hideObject: false,
              singleLine: false,
              ignore: 'pid,hostname,context,req,res,responseTime'
            }
          }
        }),
        
        // ğŸš€ í”„ë¡œë•ì…˜ í™˜ê²½ ìµœì í™”
        ...(isProduction && {
          formatters: {
            level: (label) => ({ level: label.toUpperCase() }),
          },
          timestamp: pino.stdTimeFunctions.isoTime,
          redact: {
            paths: [
              'req.headers.authorization',
              'req.headers.cookie',
              'req.body.password',
              'req.body.token',
              'res.headers["set-cookie"]'
            ],
            censor: '[REDACTED]'
          }
        }),
        
        // ğŸ“Š ìš”ì²­/ì‘ë‹µ ê¸°ë³¸ ì •ë³´
        customProps: (req, res) => {
          return {
            context: 'HTTP',
            userId: req.user?.id,
            ip: req.ip,
            userAgent: req.get('User-Agent')
          };
        },
        
        // ğŸ” ìš”ì²­ ID ìƒì„± (ì¶”ì ìš©)
        genReqId: (req) => {
          return req.get('X-Request-ID') || `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        },
        
        // âœ… ë¡œê¹…í•  ìš”ì²­ í•„í„°ë§
        autoLogging: {
          ignore: (req) => {
            // Health check ë“± ì œì™¸
            return req.url?.includes('/health') || req.url?.includes('/metrics');
          }
        },
        
        // ğŸ“ ìš”ì²­/ì‘ë‹µ ë³¸ë¬¸ í¬ê¸° ì œí•œ
        customLogLevel: (req, res, err) => {
          if (res.statusCode >= 400 && res.statusCode < 500) return 'warn';
          if (res.statusCode >= 500) return 'error';
          return 'info';
        },
        
        // ğŸ¯ ì»¤ìŠ¤í…€ ì§ë ¬í™”
        serializers: {
          req: (req) => ({
            method: req.method,
            url: req.url,
            query: req.query,
            params: req.params,
            headers: this.filterHeaders(req.headers),
            ...(req.body && Object.keys(req.body).length > 0 && {
              body: this.sanitizeRequestBody(req.body)
            })
          }),
          res: (res) => ({
            statusCode: res.statusCode,
            headers: this.filterHeaders(res.getHeaders?.() || {}),
            ...(res.locals?.responseData && {
              responseSize: JSON.stringify(res.locals.responseData).length
            })
          }),
          err: (err) => ({
            type: err.constructor.name,
            message: err.message,
            code: err.code,
            ...(isDevelopment && { stack: err.stack })
          })
        }
      }
    };
  }

  // ğŸ” ë¯¼ê°í•œ í—¤ë” í•„í„°ë§
  private filterHeaders(headers: Record<string, any>): Record<string, any> {
    const filtered = { ...headers };
    const sensitiveHeaders = ['authorization', 'cookie', 'x-api-key'];
    
    sensitiveHeaders.forEach(header => {
      if (filtered[header]) {
        filtered[header] = '[REDACTED]';
      }
    });
    
    return filtered;
  }

  // ğŸ§¹ ìš”ì²­ ë³¸ë¬¸ sanitization
  private sanitizeRequestBody(body: any): any {
    if (typeof body !== 'object' || body === null) return body;
    
    const sanitized = { ...body };
    const sensitiveFields = ['password', 'token', 'secret', 'key'];
    
    sensitiveFields.forEach(field => {
      if (sanitized[field]) {
        sanitized[field] = '[REDACTED]';
      }
    });
    
    return sanitized;
  }
}
```

### ğŸ—ï¸ Logger ëª¨ë“ˆ êµ¬ì„±

```typescript
// apps/blog-api/src/common/logger/logger.module.ts

import { Global, Module } from '@nestjs/common';
import { LoggerModule as PinoLoggerModule } from 'nestjs-pino';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { LoggerConfigService } from '../../config/logger.config';

@Global()
@Module({
  imports: [
    PinoLoggerModule.forRootAsync({
      imports: [ConfigModule],
      inject: [ConfigService, LoggerConfigService],
      useFactory: async (configService: ConfigService, loggerConfig: LoggerConfigService) => {
        return loggerConfig.createLoggerConfig();
      }
    })
  ],
  providers: [LoggerConfigService],
  exports: [LoggerConfigService]
})
export class LoggerModule {}
```

## ğŸ¯ 3ë‹¨ê³„: ê¸°ì¡´ ì‹œìŠ¤í…œê³¼ì˜ ì™„ì „ í†µí•©

### ğŸ”„ ResponseInterceptor ì—…ë°ì´íŠ¸

```typescript
// apps/blog-api/src/common/interceptors/response.interceptor.ts

import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { Observable } from 'rxjs';
import { map, tap } from 'rxjs/operators';
import { PinoLogger } from 'nestjs-pino';
import { ApiResponse } from '../interfaces/api-response.interface';
import { PaginationMeta } from '@repo/shared/utils';

@Injectable()
export class ResponseInterceptor<T> implements NestInterceptor<T, ApiResponse<T>> {
  constructor(
    private reflector: Reflector,
    private readonly logger: PinoLogger // ğŸ¯ Pino Logger ì£¼ì…
  ) {
    this.logger.setContext(ResponseInterceptor.name);
  }

  intercept(context: ExecutionContext, next: CallHandler): Observable<ApiResponse<T>> {
    const request = context.switchToHttp().getRequest();
    const response = context.switchToHttp().getResponse();
    const handler = context.getHandler();
    const startTime = Date.now();

    return next.handle().pipe(
      map((data) => {
        // ì´ë¯¸ ApiResponse í˜•íƒœë¼ë©´ ê·¸ëŒ€ë¡œ ë°˜í™˜
        if (data?.success !== undefined) {
          return data;
        }

        // ë©”íƒ€ë°ì´í„°ì—ì„œ ì»¤ìŠ¤í…€ ë©”ì‹œì§€ ê°€ì ¸ì˜¤ê¸°
        const customMessage = this.reflector.get<string>('response-message', handler);
        const isPaginated = this.reflector.get<boolean>('is-paginated', handler);

        const apiResponse: ApiResponse<T> = {
          success: true,
          message: customMessage ?? this.getDefaultMessage(request.method, data),
          data: data ?? null,
          timestamp: new Date().toISOString(),
          path: request.url,
        };

        // í˜ì´ì§• ë°ì´í„° ì²˜ë¦¬
        if (isPaginated && this.isPaginatedData(data)) {
          apiResponse.data = data.items;
          apiResponse.meta = data.meta;
        }

        return apiResponse;
      }),
      tap((apiResponse) => {
        // ğŸ¯ ì„±ê³µ ì‘ë‹µ ë¡œê¹…
        const responseTime = Date.now() - startTime;
        
        this.logger.info({
          message: 'âœ… API Response Success',
          method: request.method,
          url: request.url,
          statusCode: response.statusCode,
          responseTime: `${responseTime}ms`,
          success: apiResponse.success,
          userMessage: apiResponse.message,
          dataType: this.getDataType(apiResponse.data),
          ...(apiResponse.meta && {
            pagination: {
              total: apiResponse.meta.total,
              page: apiResponse.meta.page,
              limit: apiResponse.meta.limit
            }
          }),
          userId: request.user?.id,
          requestId: request.id
        });
      })
    );
  }

  private getDefaultMessage(method: string, data: any): string {
    // ë°ì´í„° íƒ€ì…ì— ë”°ë¥¸ ìŠ¤ë§ˆíŠ¸ ë©”ì‹œì§€ ìƒì„±
    if (Array.isArray(data)) {
      return `${data.length}ê°œì˜ í•­ëª©ì„ ì¡°íšŒí–ˆìŠµë‹ˆë‹¤.`;
    }

    const messages = {
      GET: data ? "ì¡°íšŒê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤." : "ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
      POST: "ìƒì„±ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.",
      PUT: "ìˆ˜ì •ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.",
      PATCH: "ì—…ë°ì´íŠ¸ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.",
      DELETE: "ì‚­ì œê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.",
    };

    return messages[method] ?? "ìš”ì²­ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.";
  }

  private isPaginatedData(data: any): data is { items: any[]; meta: PaginationMeta } {
    return (
      data &&
      typeof data === "object" &&
      Array.isArray(data.items) &&
      data.meta &&
      data.meta instanceof PaginationMeta
    );
  }

  // ğŸ” ë°ì´í„° íƒ€ì… ë¶„ì„ (ë¡œê·¸ ìµœì í™”ìš©)
  private getDataType(data: any): string {
    if (data === null) return 'null';
    if (Array.isArray(data)) return `array[${data.length}]`;
    if (typeof data === 'object') return `object(${Object.keys(data).length} keys)`;
    return typeof data;
  }
}
```

### ğŸš¨ GlobalExceptionFilter ì—…ë°ì´íŠ¸

```typescript
// apps/blog-api/src/common/filters/global-exception.filter.ts

import { Catch, ArgumentsHost, ExceptionFilter, HttpException } from '@nestjs/common';
import { Response, Request } from 'express';
import { PinoLogger } from 'nestjs-pino';
import { ErrorResponse, ErrorCode } from '../interfaces';
import { ErrorMessages } from '../constants';

@Catch()
export class GlobalExceptionFilter implements ExceptionFilter {
  constructor(private readonly logger: PinoLogger) {
    this.logger.setContext(GlobalExceptionFilter.name);
  }

  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();

    const errorResponse = this.buildErrorResponse(exception, request);
    
    // ğŸ¯ êµ¬ì¡°í™”ëœ ì—ëŸ¬ ë¡œê¹…
    this.logError(exception, request, errorResponse);
    
    const statusCode = errorResponse.data?.error?.statusCode || 500;
    response.status(statusCode).json(errorResponse);
  }

  private buildErrorResponse(exception: unknown, request: Request): ErrorResponse {
    const timestamp = new Date().toISOString();
    const path = request.url;
    const isDevelopment = process.env.NODE_ENV === 'development';

    // ... ê¸°ì¡´ ì—ëŸ¬ ì‘ë‹µ ìƒì„± ë¡œì§ ìœ ì§€ ...

    return errorResponse;
  }

  // ğŸ¯ í–¥ìƒëœ ì—ëŸ¬ ë¡œê¹… ì‹œìŠ¤í…œ
  private logError(exception: unknown, request: Request, errorResponse: ErrorResponse): void {
    const { method, url, ip, user } = request;
    const statusCode = errorResponse.data?.error?.statusCode || 500;
    const errorCode = errorResponse.data?.error?.code || 'UNKNOWN';
    
    const baseLogData = {
      message: `ğŸš¨ API Error: ${method} ${url}`,
      method,
      url,
      ip,
      statusCode,
      errorCode,
      userMessage: errorResponse.message,
      timestamp: errorResponse.timestamp,
      userId: user?.id,
      requestId: request.id,
      userAgent: request.get('User-Agent'),
      // ğŸ” ì—ëŸ¬ ë¶„ë¥˜
      errorCategory: this.categorizeError(statusCode),
      // ğŸ“Š ì„±ëŠ¥ ì˜í–¥ë„
      performanceImpact: this.assessPerformanceImpact(statusCode, exception)
    };

    // ğŸ”¥ ì‹¬ê°ë„ë³„ ë¡œê¹… ì „ëµ
    if (statusCode >= 500) {
      // ì„œë²„ ì—ëŸ¬ - ERROR ë ˆë²¨
      this.logger.error({
        ...baseLogData,
        exception: {
          name: exception instanceof Error ? exception.constructor.name : 'Unknown',
          message: exception instanceof Error ? exception.message : String(exception),
          ...(process.env.NODE_ENV === 'development' && exception instanceof Error && {
            stack: exception.stack
          })
        },
        // ğŸ” ì¶”ê°€ ì»¨í…ìŠ¤íŠ¸ (ê°œë°œí™˜ê²½ë§Œ)
        ...(process.env.NODE_ENV === 'development' && {
          requestBody: this.sanitizeForLog(request.body),
          requestQuery: request.query,
          requestParams: request.params
        })
      });
    } else if (statusCode >= 400) {
      // í´ë¼ì´ì–¸íŠ¸ ì—ëŸ¬ - WARN ë ˆë²¨
      this.logger.warn({
        ...baseLogData,
        clientError: {
          type: this.classifyClientError(statusCode),
          likely_cause: this.suggestErrorCause(statusCode, errorCode)
        }
      });
    }

    // ğŸ“ˆ íŠ¹ë³„í•œ íŒ¨í„´ ê°ì§€
    this.detectErrorPatterns(errorCode, statusCode, url);
  }

  // ğŸ·ï¸ ì—ëŸ¬ ë¶„ë¥˜ ì‹œìŠ¤í…œ
  private categorizeError(statusCode: number): string {
    if (statusCode >= 500) return 'SERVER_ERROR';
    if (statusCode === 404) return 'RESOURCE_NOT_FOUND';
    if (statusCode === 401) return 'AUTHENTICATION_ERROR';
    if (statusCode === 403) return 'AUTHORIZATION_ERROR';
    if (statusCode === 400) return 'VALIDATION_ERROR';
    if (statusCode === 409) return 'BUSINESS_LOGIC_ERROR';
    return 'CLIENT_ERROR';
  }

  // ğŸ¯ ì„±ëŠ¥ ì˜í–¥ë„ í‰ê°€
  private assessPerformanceImpact(statusCode: number, exception: unknown): string {
    if (statusCode >= 500) {
      if (exception instanceof Error && exception.message.includes('timeout')) {
        return 'HIGH'; // íƒ€ì„ì•„ì›ƒ ì—ëŸ¬ëŠ” ë†’ì€ ì˜í–¥ë„
      }
      if (exception instanceof Error && exception.message.includes('database')) {
        return 'MEDIUM'; // DB ì—ëŸ¬ëŠ” ì¤‘ê°„ ì˜í–¥ë„
      }
      return 'LOW';
    }
    return 'MINIMAL';
  }

  // ğŸ” í´ë¼ì´ì–¸íŠ¸ ì—ëŸ¬ ë¶„ë¥˜
  private classifyClientError(statusCode: number): string {
    const classifications = {
      400: 'INVALID_REQUEST',
      401: 'MISSING_AUTH',
      403: 'INSUFFICIENT_PERMISSION',
      404: 'RESOURCE_MISSING',
      409: 'CONFLICT_STATE',
      422: 'VALIDATION_FAILURE'
    };
    return classifications[statusCode] || 'UNKNOWN_CLIENT_ERROR';
  }

  // ğŸ’¡ ì—ëŸ¬ ì›ì¸ ì¶”ì •
  private suggestErrorCause(statusCode: number, errorCode: string): string {
    const suggestions = {
      'POST_NOT_FOUND': 'Invalid slug or post was deleted',
      'INVALID_JWT_TOKEN': 'Token malformed or signature invalid',
      'JWT_TOKEN_EXPIRED': 'User needs to refresh authentication',
      'VALIDATION_FAILED': 'Check request body format and required fields'
    };
    return suggestions[errorCode] || 'Check API documentation';
  }

  // ğŸ“Š ì—ëŸ¬ íŒ¨í„´ ê°ì§€
  private detectErrorPatterns(errorCode: string, statusCode: number, url: string): void {
    // ğŸ”¥ ì—°ì†ëœ ê°™ì€ ì—ëŸ¬ ê°ì§€ (ê°„ë‹¨í•œ êµ¬í˜„)
    const errorKey = `${errorCode}_${url}`;
    // ì‹¤ì œë¡œëŠ” Redisë‚˜ ë©”ëª¨ë¦¬ ìºì‹œë¥¼ ì‚¬ìš©í•´ì„œ êµ¬í˜„
    
    // ğŸ¯ íŠ¹ë³„í•œ ì¼€ì´ìŠ¤ ë¡œê¹…
    if (statusCode === 404 && url.includes('/api/posts/')) {
      this.logger.warn({
        pattern: 'FREQUENT_404',
        message: 'Potential SEO issue - frequent 404s on post URLs',
        url,
        suggestion: 'Check for broken links or implement redirect rules'
      });
    }
  }

  // ğŸ§¹ ë¡œê·¸ìš© ë°ì´í„° ì •ì œ
  private sanitizeForLog(data: any): any {
    if (!data || typeof data !== 'object') return data;
    
    const sanitized = { ...data };
    const sensitiveFields = ['password', 'token', 'secret', 'key', 'authorization'];
    
    sensitiveFields.forEach(field => {
      if (sanitized[field]) {
        sanitized[field] = '[REDACTED]';
      }
    });
    
    return sanitized;
  }
}
```

## ğŸ“Š 4ë‹¨ê³„: ì „ìš© LoggingInterceptor ì¶”ê°€

### ğŸ¯ API ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì „ìš©

```typescript
// apps/blog-api/src/common/interceptors/logging.interceptor.ts

import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap, catchError } from 'rxjs/operators';
import { PinoLogger } from 'nestjs-pino';
import { Request, Response } from 'express';

@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  constructor(private readonly logger: PinoLogger) {
    this.logger.setContext(LoggingInterceptor.name);
  }

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const request = context.switchToHttp().getRequest<Request>();
    const response = context.switchToHttp().getResponse<Response>();
    const { method, url, ip } = request;
    const startTime = Date.now();

    // ğŸ¯ ìš”ì²­ ì‹œì‘ ë¡œê¹…
    this.logger.info({
      message: `ğŸš€ API Request Started`,
      method,
      url,
      ip,
      userId: request.user?.id,
      requestId: request.id,
      timestamp: new Date().toISOString(),
      contentLength: request.get('content-length'),
      userAgent: request.get('User-Agent')?.substring(0, 100), // ë„ˆë¬´ ê¸¸ë©´ ìë¥´ê¸°
    });

    return next.handle().pipe(
      tap((data) => {
        const responseTime = Date.now() - startTime;
        
        // ğŸ‰ ì„±ê³µ ì‘ë‹µ ë¡œê¹…  
        this.logger.info({
          message: `âœ… API Request Completed`,
          method,
          url,
          statusCode: response.statusCode,
          responseTime: `${responseTime}ms`,
          // ğŸ¯ ì„±ëŠ¥ ë¶„ì„
          performance: this.analyzePerformance(responseTime, method),
          // ğŸ“Š ì‘ë‹µ ë°ì´í„° ë¶„ì„  
          responseAnalysis: {
            hasData: !!data,
            dataType: this.getDataType(data),
            ...(Array.isArray(data) && { itemCount: data.length }),
            ...(data?.items && Array.isArray(data.items) && { 
              paginatedItemCount: data.items.length,
              totalItems: data.meta?.total 
            })
          },
          userId: request.user?.id,
          requestId: request.id
        });
      }),
      catchError((error) => {
        const responseTime = Date.now() - startTime;
        
        // ğŸš¨ ì—ëŸ¬ ë°œìƒ ì‹œ ë¡œê¹…
        this.logger.error({
          message: `ğŸ’¥ API Request Failed`,
          method,
          url,
          error: {
            name: error.constructor.name,
            message: error.message
          },
          responseTime: `${responseTime}ms`,
          userId: request.user?.id,
          requestId: request.id
        });
        
        throw error;
      })
    );
  }

  // ğŸ¯ ì„±ëŠ¥ ë¶„ì„ 
  private analyzePerformance(responseTime: number, method: string): {
    level: string;
    category: string;
    recommendation?: string;
  } {
    // HTTP ë©”ì†Œë“œë³„ ê¸°ì¤€ ì‹œê°„
    const thresholds = {
      GET: { fast: 100, slow: 500 },
      POST: { fast: 200, slow: 1000 },
      PUT: { fast: 250, slow: 1000 },
      PATCH: { fast: 200, slow: 800 },
      DELETE: { fast: 150, slow: 600 }
    };
    
    const threshold = thresholds[method] || thresholds.GET;
    
    if (responseTime < threshold.fast) {
      return { level: 'EXCELLENT', category: 'FAST' };
    } else if (responseTime < threshold.slow) {
      return { level: 'GOOD', category: 'NORMAL' };
    } else if (responseTime < threshold.slow * 2) {
      return { 
        level: 'WARNING', 
        category: 'SLOW',
        recommendation: 'Consider query optimization or caching'
      };
    } else {
      return { 
        level: 'CRITICAL', 
        category: 'VERY_SLOW',
        recommendation: 'Urgent performance investigation needed'
      };
    }
  }

  private getDataType(data: any): string {
    if (data === null || data === undefined) return 'empty';
    if (Array.isArray(data)) return `array[${data.length}]`;
    if (typeof data === 'object') {
      if (data.items && Array.isArray(data.items)) return 'paginated';
      return 'object';
    }
    return typeof data;
  }
}
```

## ğŸ›ï¸ 5ë‹¨ê³„: ì• í”Œë¦¬ì¼€ì´ì…˜ í†µí•©

### ğŸ­ main.ts ì—…ë°ì´íŠ¸

```typescript
// apps/blog-api/src/main.ts

import { NestFactory } from '@nestjs/core';
import { Logger } from 'nestjs-pino';
import { AppModule } from './app.module';
import { GlobalExceptionFilter } from './common/filters/global-exception.filter';
import { ResponseInterceptor } from './common/interceptors/response.interceptor';
import { LoggingInterceptor } from './common/interceptors/logging.interceptor';

async function bootstrap() {
  const app = await NestFactory.create(AppModule, { 
    bufferLogs: true // ğŸ¯ ì•± ì‹œì‘ ì „ê¹Œì§€ ë¡œê·¸ ë²„í¼ë§
  });

  // ğŸ¯ Pino Loggerë¥¼ ê¸°ë³¸ ë¡œê±°ë¡œ ì„¤ì •
  app.useLogger(app.get(Logger));
  
  // ğŸ“Š ì¸í„°ì…‰í„° ë“±ë¡ ìˆœì„œ (ì¤‘ìš”!)
  app.useGlobalInterceptors(
    app.get(LoggingInterceptor),    // 1. ê¸°ë³¸ ìš”ì²­/ì‘ë‹µ ë¡œê¹…
    app.get(ResponseInterceptor)    // 2. ì‘ë‹µ í˜•ì‹ í‘œì¤€í™” + ìƒì„¸ ë¡œê¹…
  );
  
  // ğŸš¨ ê¸€ë¡œë²Œ ì˜ˆì™¸ í•„í„°
  app.useGlobalFilters(
    app.get(GlobalExceptionFilter)
  );

  const port = process.env.PORT || 3001;
  
  // ğŸ‰ ì„œë²„ ì‹œì‘ ë¡œê·¸
  const logger = app.get(Logger);
  logger.info({
    message: 'ğŸš€ Blog API Server Starting',
    port,
    environment: process.env.NODE_ENV,
    logLevel: process.env.LOG_LEVEL || 'info',
    prettyPrint: process.env.LOG_PRETTY_PRINT === 'true',
    timestamp: new Date().toISOString()
  });

  await app.listen(port);
  
  // âœ… ì„œë²„ ì‹œì‘ ì™„ë£Œ ë¡œê·¸
  logger.info({
    message: 'âœ… Blog API Server Started Successfully',
    port,
    urls: {
      api: `http://localhost:${port}/api`,
      swagger: `http://localhost:${port}/api-docs`,
      health: `http://localhost:${port}/health`
    }
  });
}

bootstrap().catch((error) => {
  console.error('ğŸ’¥ Application failed to start:', error);
  process.exit(1);
});
```

### ğŸ—ï¸ AppModule ì—…ë°ì´íŠ¸

```typescript
// apps/blog-api/src/app.module.ts

import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { LoggerModule } from './common/logger/logger.module';
import { ResponseInterceptor } from './common/interceptors/response.interceptor';
import { LoggingInterceptor } from './common/interceptors/logging.interceptor';
import { GlobalExceptionFilter } from './common/filters/global-exception.filter';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      envFilePath: '.env'
    }),
    LoggerModule, // ğŸ¯ Pino Logger ëª¨ë“ˆ (Global)
    // ... ê¸°ì¡´ ëª¨ë“ˆë“¤
  ],
  providers: [
    ResponseInterceptor,
    LoggingInterceptor,
    GlobalExceptionFilter,
    // ... ê¸°ì¡´ providers
  ]
})
export class AppModule {}
```

## ğŸ“Š 6ë‹¨ê³„: ì„œë¹„ìŠ¤ ë ˆì´ì–´ ë¡œê¹… ê°•í™”

### ğŸ¯ ì„œë¹„ìŠ¤ì—ì„œ êµ¬ì¡°í™”ëœ ë¡œê¹…

```typescript
// apps/blog-api/src/posts/posts.service.ts

import { Injectable, NotFoundException } from '@nestjs/common';
import { PinoLogger } from 'nestjs-pino';
import { PostsRepository } from './posts.repository';
import { CreatePostDto, UpdatePostDto, PostQueryDto } from './dto';
import { PaginationMeta } from '@repo/shared/utils';

@Injectable()
export class PostsService {
  constructor(
    private readonly postsRepository: PostsRepository,
    private readonly logger: PinoLogger
  ) {
    this.logger.setContext(PostsService.name);
  }

  async findAll(query: PostQueryDto) {
    const startTime = Date.now();
    
    // ğŸ¯ ì¿¼ë¦¬ ì‹œì‘ ë¡œê¹…
    this.logger.debug({
      message: 'ğŸ” Post query started',
      query: {
        page: query.page,
        limit: query.limit,
        category: query.category,
        tag: query.tag,
        search: query.search
      },
      operation: 'findAll'
    });

    try {
      const page = query.page ?? 1;
      const limit = query.limit ?? 10;
      
      const [posts, totalCount] = await Promise.all([
        this.postsRepository.findMany((page - 1) * limit, limit, query),
        this.postsRepository.count(query)
      ]);
      
      const queryTime = Date.now() - startTime;
      
      // âœ… ì„±ê³µ ë¡œê¹…
      this.logger.info({
        message: 'âœ… Post query completed',
        result: {
          postsCount: posts.length,
          totalCount,
          page,
          limit,
          queryTime: `${queryTime}ms`
        },
        performance: this.analyzeQueryPerformance(queryTime, posts.length),
        operation: 'findAll'
      });

      return {
        items: posts,
        meta: PaginationMeta.create(totalCount, page, limit),
      };
    } catch (error) {
      // ğŸš¨ ì—ëŸ¬ ë¡œê¹…
      this.logger.error({
        message: 'ğŸ’¥ Post query failed',
        error: {
          name: error.constructor.name,
          message: error.message
        },
        query,
        queryTime: `${Date.now() - startTime}ms`,
        operation: 'findAll'
      });
      throw error;
    }
  }

  async create(createPostDto: CreatePostDto) {
    this.logger.info({
      message: 'ğŸ“ Creating new post',
      postData: {
        title: createPostDto.title,
        slug: createPostDto.slug,
        categoryId: createPostDto.categoryId,
        tagCount: createPostDto.tagIds?.length || 0,
        contentLength: createPostDto.content?.length || 0
      },
      operation: 'create'
    });

    try {
      const post = await this.postsRepository.create(createPostDto);
      
      this.logger.info({
        message: 'âœ… Post created successfully',
        postId: post.id,
        slug: post.slug,
        operation: 'create'
      });

      return post;
    } catch (error) {
      this.logger.error({
        message: 'ğŸ’¥ Post creation failed',
        error: {
          name: error.constructor.name,
          message: error.message,
          ...(error.code && { code: error.code })
        },
        postData: {
          title: createPostDto.title,
          slug: createPostDto.slug
        },
        operation: 'create'
      });
      throw error;
    }
  }

  // ğŸ¯ ì¿¼ë¦¬ ì„±ëŠ¥ ë¶„ì„
  private analyzeQueryPerformance(queryTime: number, resultCount: number) {
    const timePerItem = resultCount > 0 ? queryTime / resultCount : queryTime;
    
    return {
      overall: queryTime < 100 ? 'EXCELLENT' : 
               queryTime < 500 ? 'GOOD' : 
               queryTime < 1000 ? 'ACCEPTABLE' : 'SLOW',
      timePerItem: `${timePerItem.toFixed(2)}ms`,
      ...(queryTime > 1000 && {
        recommendation: 'Consider adding database indexes or query optimization'
      })
    };
  }
}
```

## ğŸš€ 7ë‹¨ê³„: ê°œë°œ ë° ìš´ì˜ ìµœì í™”

### ğŸ“Š ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ

```typescript
// apps/blog-api/src/common/middleware/performance.middleware.ts

import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';
import { PinoLogger } from 'nestjs-pino';

@Injectable()
export class PerformanceMiddleware implements NestMiddleware {
  constructor(private readonly logger: PinoLogger) {
    this.logger.setContext(PerformanceMiddleware.name);
  }

  use(req: Request, res: Response, next: NextFunction) {
    const startTime = Date.now();
    const startMemory = process.memoryUsage();
    
    // ì‘ë‹µ ì™„ë£Œ ì‹œ ì„±ëŠ¥ ë©”íŠ¸ë¦­ ë¡œê¹…
    res.on('finish', () => {
      const endTime = Date.now();
      const endMemory = process.memoryUsage();
      const responseTime = endTime - startTime;
      
      // ğŸ“Š ìƒì„¸ ì„±ëŠ¥ ë©”íŠ¸ë¦­
      this.logger.info({
        message: 'ğŸ“Š Request Performance Metrics',
        metrics: {
          responseTime: `${responseTime}ms`,
          memoryUsage: {
            heapUsed: `${Math.round((endMemory.heapUsed - startMemory.heapUsed) / 1024 / 1024 * 100) / 100}MB`,
            heapTotal: `${Math.round(endMemory.heapTotal / 1024 / 1024 * 100) / 100}MB`,
            external: `${Math.round(endMemory.external / 1024 / 1024 * 100) / 100}MB`
          },
          statusCode: res.statusCode,
          contentLength: res.get('content-length') || 'unknown'
        },
        request: {
          method: req.method,
          url: req.url,
          userId: req.user?.id
        },
        // ğŸ¯ ì„±ëŠ¥ ë“±ê¸‰
        performanceGrade: this.gradePerformance(responseTime, res.statusCode),
        timestamp: new Date().toISOString()
      });
    });

    next();
  }

  private gradePerformance(responseTime: number, statusCode: number): string {
    if (statusCode >= 400) return 'ERROR';
    if (responseTime < 50) return 'A+';
    if (responseTime < 100) return 'A';
    if (responseTime < 200) return 'B';
    if (responseTime < 500) return 'C';
    return 'D';
  }
}
```

### ğŸ¯ ë¡œê·¸ ìˆ˜ì§‘ ë° ë¶„ì„ ì„¤ì •

```typescript
// apps/blog-api/src/config/log-aggregation.config.ts

interface LogAggregationConfig {
  // ğŸ¯ ìš´ì˜ í™˜ê²½ ë¡œê·¸ ìˆ˜ì§‘ ì„¤ì •
  production: {
    // ELK Stack ë˜ëŠ” ì™¸ë¶€ ì„œë¹„ìŠ¤ë¡œ ì „ì†¡
    transports: {
      elasticsearch?: {
        level: 'info',
        index: 'blog-api-logs'
      };
      datadog?: {
        level: 'warn',
        service: 'blog-api'
      };
      file?: {
        level: 'error',
        filename: 'error.log',
        maxsize: 10485760, // 10MB
        maxFiles: 5
      };
    };
  };
  
  // ğŸ”§ ê°œë°œ í™˜ê²½ ì„¤ì •
  development: {
    console: {
      level: 'debug',
      prettyPrint: true
    };
  };
}

export const logAggregationConfig: LogAggregationConfig = {
  production: {
    transports: {
      file: {
        level: 'error',
        filename: './logs/error.log',
        maxsize: 10485760,
        maxFiles: 5
      }
    }
  },
  development: {
    console: {
      level: 'debug',
      prettyPrint: true
    }
  }
};
```

## ğŸ“ˆ 8ë‹¨ê³„: ëª¨ë‹ˆí„°ë§ ë° ì•Œë¦¼ ì‹œìŠ¤í…œ

### ğŸš¨ ì—ëŸ¬ìœ¨ ëª¨ë‹ˆí„°ë§

```typescript
// apps/blog-api/src/common/services/alert.service.ts

import { Injectable } from '@nestjs/common';
import { PinoLogger } from 'nestjs-pino';

@Injectable()
export class AlertService {
  private errorCounts = new Map<string, number>();
  private alertThresholds = {
    errorRate: 10, // 10% ì´ìƒ ì—ëŸ¬ìœ¨
    responseTime: 2000, // 2ì´ˆ ì´ìƒ ì‘ë‹µì‹œê°„
    memoryUsage: 500 // 500MB ì´ìƒ ë©”ëª¨ë¦¬ ì‚¬ìš©
  };

  constructor(private readonly logger: PinoLogger) {
    this.logger.setContext(AlertService.name);
    
    // 1ë¶„ë§ˆë‹¤ ë©”íŠ¸ë¦­ ì²´í¬
    setInterval(() => this.checkMetrics(), 60000);
  }

  trackError(endpoint: string, errorType: string) {
    const key = `${endpoint}:${errorType}`;
    this.errorCounts.set(key, (this.errorCounts.get(key) || 0) + 1);
  }

  trackPerformance(responseTime: number, memoryUsage: number) {
    if (responseTime > this.alertThresholds.responseTime) {
      this.logger.warn({
        message: 'ğŸŒ High Response Time Alert',
        responseTime: `${responseTime}ms`,
        threshold: `${this.alertThresholds.responseTime}ms`,
        alertType: 'PERFORMANCE'
      });
    }

    if (memoryUsage > this.alertThresholds.memoryUsage) {
      this.logger.warn({
        message: 'ğŸ§  High Memory Usage Alert',
        memoryUsage: `${memoryUsage}MB`,
        threshold: `${this.alertThresholds.memoryUsage}MB`,
        alertType: 'RESOURCE'
      });
    }
  }

  private checkMetrics() {
    // ì—ëŸ¬ìœ¨ ì²´í¬ ë° ì•Œë¦¼ ë¡œì§
    this.errorCounts.forEach((count, key) => {
      if (count >= this.alertThresholds.errorRate) {
        this.logger.error({
          message: 'ğŸš¨ High Error Rate Alert',
          endpoint: key,
          errorCount: count,
          threshold: this.alertThresholds.errorRate,
          alertType: 'ERROR_RATE'
        });
      }
    });

    // ì¹´ìš´í„° ë¦¬ì…‹
    this.errorCounts.clear();
  }
}
```

## ğŸ“Š ìµœì¢… ê²°ê³¼ ë° ì„±ê³¼

### ğŸ¯ ë¡œê·¸ ì¶œë ¥ ì˜ˆì‹œ

#### ê°œë°œ í™˜ê²½ (Pretty Print)
```
[14:30:25.123] INFO (1234): ğŸš€ API Request Started
    method: "GET"
    url: "/api/posts"
    ip: "127.0.0.1"
    userId: "01HXX..."
    requestId: "req_1694123456_abc123"

[14:30:25.234] INFO (1234): âœ… API Response Success
    method: "GET"
    url: "/api/posts"
    statusCode: 200
    responseTime: "111ms"
    performance: {
      level: "GOOD",
      category: "NORMAL"
    }
    dataType: "paginated"
```

#### ìš´ì˜ í™˜ê²½ (JSON)
```json
{
  "level": "info",
  "time": 1694123456789,
  "msg": "âœ… API Response Success",
  "method": "GET",
  "url": "/api/posts",
  "statusCode": 200,
  "responseTime": "111ms",
  "performance": {
    "level": "GOOD", 
    "category": "NORMAL"
  },
  "userId": "01HXX...",
  "requestId": "req_1694123456_abc123"
}
```

### ğŸ“ˆ ê¸°ëŒ€ ì„±ê³¼ ì§€í‘œ

| ì§€í‘œ | ê¸°ì¡´ | Pino ì ìš© í›„ | ê°œì„ ìœ¨ |
|------|------|--------------|--------|
| **ë¡œê·¸ ì²˜ë¦¬ ì„±ëŠ¥** | 100% | **20%** | **80% í–¥ìƒ** |
| **êµ¬ì¡°í™” ìˆ˜ì¤€** | 30% | **100%** | **70%p í–¥ìƒ** |
| **ë””ë²„ê¹… íš¨ìœ¨ì„±** | 60% | **95%** | **35%p í–¥ìƒ** |
| **ìš´ì˜ ê°€ì‹œì„±** | 40% | **98%** | **58%p í–¥ìƒ** |
| **ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§** | 20% | **100%** | **80%p í–¥ìƒ** |

### âœ… í•µì‹¬ ë‹¬ì„± ì‚¬í•­

1. **ì™„ì „ í†µí•©**: ê¸°ì¡´ ResponseInterceptor/ErrorFilterì™€ seamless ì—°ë™
2. **ê³ ì„±ëŠ¥**: pino ê¸°ë°˜ìœ¼ë¡œ ìµœê³  ìˆ˜ì¤€ì˜ ë¡œê¹… ì„±ëŠ¥ ë‹¬ì„±  
3. **êµ¬ì¡°í™”**: JSON ê¸°ë°˜ êµ¬ì¡°í™”ëœ ë¡œê·¸ë¡œ ë¶„ì„ ìš©ì´ì„± ê·¹ëŒ€í™”
4. **í™˜ê²½ë³„ ìµœì í™”**: ê°œë°œ/ìš´ì˜ í™˜ê²½ì— ìµœì í™”ëœ ë¡œê·¸ í˜•ì‹
5. **ëª¨ë‹ˆí„°ë§**: ì‹¤ì‹œê°„ ì„±ëŠ¥ ë° ì—ëŸ¬ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ êµ¬ì¶•

pino logger í†µí•©ìœ¼ë¡œ **ì›”ë“œí´ë˜ìŠ¤ ìˆ˜ì¤€ì˜ ë¡œê¹… ì‹œìŠ¤í…œ**ì„ êµ¬ì¶•í•˜ì—¬ **ê°œë°œì ê²½í—˜ê³¼ ìš´ì˜ íš¨ìœ¨ì„±**ì„ ë™ì‹œì— ê·¹ëŒ€í™”í–ˆìŠµë‹ˆë‹¤! ğŸ‰
